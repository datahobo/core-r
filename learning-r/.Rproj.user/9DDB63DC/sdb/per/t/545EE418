{
    "contents" : "# Cleaning and Transforming Data\n\n## Goals:\n# Know how to manipulate strings and clean categorical variables\n# Subset and transform data frames\n# Change the shape of a data frame from wide to long and back again\n# Understand sorting and ordering\n\n## Cleaning Strings\n# Combine strings together using paste\n# Extract sections of a string with substring\n# Converting logical values - alpe_d_huez data\n# we'll create a function:\nyn_to_logical <- function(x)\n{\n  y <- rep.int(NA, length(x)) # Setting a default first lets us handle exceptions\n  y[x == \"Y\"] <- TRUE\n  y[x == \"N\"] <- FALSE\n  return(y) # Need the last line to ensure the function returns the correct value\n}\n# calling it:\nbikeData$DrugUse <- yn_to_logical(bikeData$DrugUse)\n\n# You can do a lot with grep matching - regular expressions\n# use stringr for everything\nlibrary(stringr)\ndata(english_monarchs, package = \"learningr\")\nhead(english_monarchs)\n\n# we can look for kingdoms that merged based on commas in the domain column\n# do it the way the book suggests, this keeps the row numbers\nmultipleKingdoms <- str_detect(english_monarchs$domain, fixed(\",\"))\nenglish_monarchs[multipleKingdoms, c(\"name\", \"domain\")]\n# or create your own data frame\nenglish_monarchs$manyKingdoms <- str_detect(english_monarchs$domain, fixed(\",\"))\nmultiKingdoms <- subset(english_monarchs, manyKingdoms, select = c(name, domain))\nView(multiKingdoms)\n\n# we can look for multiple rulers using either , or and\n# use a regex\n# book-style:\nmultipleRulers <- str_detect(english_monarchs$name, \",|and\")\nenglish_monarchs$name[multipleRulers & !is.na(multipleRulers)]\n\n# Let's split out the rulers by multiples:\nindividualRulers <- str_split(english_monarchs$name, \", | and\")\nhead(individualRulers[sapply(individualRulers, length) > 1]) # Now find the\n# first instances of cases where there is more than one ruler\n\n# how many times are old english characters used in each ruler's name?\nth <- c(\"th\", \"ð\", \"þ\")\nsapply(\n  th, function(th)\n    {\n    sum(str_count(english_monarchs$name, th))\n  }\n)\n\n# we can use str_replace_all to fix all of them at once\nenglish_monarchs$newName <- str_replace_all(english_monarchs$name, \"[ðþ]\", \"th\")\n\n# this can be really useful for cleaning up categorical variables\ngender <- c( \"MALE\", \"Male\", \"male\", \"M\", \"FEMALE\", \"Female\", \"female\", \"f\", NA )\n\ncleanGender <- str_replace(gender, ignore.case(\"^m(ale)?$\"), \"Male\")\n(cleanGender <- str_replace(cleanGender, ignore.case(\"^f(emale)?$\"), \"Female\"))\n\n## Manipulating data frames\n# We can add more columns, or replace existing ones\n# We can deal with missing values\n# We can convert between the wide and long forms of a data frame\n\n## Adding and Replacing Columns\nenglish_monarchs$length.of.reign.years <-\n  english_monarchs$end.of.reign -\nenglish_monarchs$start.of.reign\n\n# with makes it easier\nenglish_monarchs$length.of.reign.years <- with(\n  english_monarchs, end.of.reign - start.of.reign)\n\n# within returns the whole data frame, good for multiple columns\nenglish_monarchs <- within(\n  english_monarchs, {length.of.reign.years <-\n                     end.of.reign - start.of.reign\n                     reign.more.than.30.years <- length.of.reign.years > 30})\n\n# you can also uses mutate in the plyr package - takes new and \n# revised columns as name-value pairs\n\n## Dealing with Missing Values\n# Use complete.cases to know which rows are free of missing values:\ndata(\"deer_endocranial_volume\", package = \"learningr\")\nhas.all.measurements <- complete.cases(deer_endocranial_volume)\ndeer_endocranial_volume[has.all.measurements, ]\n\n# na.omit is a good shortcut\nna.omit(deer_endocranial_volume)\n\n# na.fail throws an error if your data frame has missing values\nna.fail(deer_endocranial_volume)\n\n## Converting between wide and long form\ndeer.wide <- deer_endocranial_volume[, 1:5]\n\n\n# if there are multiple measurements taken of one deer, we can put all the\n# measurements into the correct column type, then a column with skull ID and\n# a column with a factor identifying the measurement type. This is the long form\n\n# Use reshape2\ninstall.packages(\"reshape2\")\nlibrary(reshape2)\ndeerLong <- melt(deer.wide, id.vars = \"SkullID\")\nhead(deerLong)\n\n# you can do it with measure.vars alternatively, if you have more id vars than\n# measure vars:\n\nmelt(deer.wide, measure.vars = c(\"VolCT\", \"VolBead\", \"VolLWH\", \"VolFinarelli\"))\n\n# dcast converts back from long to wide and returns the result as a data frame\ndeer.wide.again <- dcast(deerLong, SkullID ~ variable)\nView(deer.wide.again)\n\n# Using SQL\n## sqldf allows you to manipulate data frames using SQL:\ninstall.packages(\"sqldf\")\nlibrary(sqldf)\n\n# Subsets:\n# R:\nsubset(deer_endocranial_volume, VolCT > 400 | VolCT2 > 400, c(VolCT, VolCT2))\n# SQL:\nquery <- \"SELECT VolCT, VolCT2 FROM deer_endocranial_volume\nWHERE VolCT > 400 OR VolCT2 > 400\"\nsqldf(query)\n\n## Sorting\n# use sort\n\nx <- c(2, 32, 4, 16, 8)\nsort(x)\nsort(x, decreasing = TRUE)\n\n# Strings can be sorted, but the order depends on locale\n# Use ?Comparison to know what the differences are\nsort(c(\"I\", \"shot\", \"the\", \"city\", \"sheriff\"))\n\n# order is an inverse to sort - it refers to the index instead of the element\n# x[order(x)]\n# returns the same value as\n# sort(x)\n\norder(x)\nx[order(x)]\nidentical(sort(x), x[order(x)])\n\n# order is useful for sorting data frames\nyear.order <- order(english_monarchs$start.of.reign)\nenglish_monarchs[year.order, ]\n\n# plyr makes sorting data frames really easy\nlibrary(plyr)\narrange(english_monarchs, start.of.reign)\n\n# rank gives the rank of each element in a dataset\n(x <- sample(3, 7, replace = TRUE))\nrank(x)\nrank(x, ties.method = \"first\")\n\n# functional programming\n# negate takes a predicate (logical function), and returns the opposite\nct2 <- deer_endocranial_volume$VolCT2 # for convenience\nisnt.na <- Negate(is.na)\nidentical(isnt.na(ct2), !is.na(ct2))\n\n# Filter takes a function that returns a logical vector and an input vector,\n# and returns only those values where the function returns TRUE\nFilter(isnt.na, ct2)\n\n# Position is kind of like which - returns the first index where applying \n# a predicate to a vector returns TRUE:\nPosition(isnt.na, ct2)\n\n# Find is similar to Position, but returns the first value rather than index\nFind(isnt.na, ct2)\n\n# Map applies a function element-wise to its inputs.\n# first we need a function to pass to Map\nget_volume <- function(ct, bead, lwh, finarelli, ct2, bead2, lwh2) {\n  # If there is a second measurement, take the average\n  if (!is.na(ct2)) {\n    ct <- (ct + ct2) / 2\n    bead <- (bead + bead2) / 2\n    lwh <- (lwh + lwh2) / 2\n  }\n  # Divide lwh by 4 to bring it line with the other measurements\n  c(ct = ct, bead = bead, lwh.4 = lwh / 4, finarelli = finarelli)\n}\n\nmeasurements.by.deer <- with(deer_endocranial_volume,\n                             Map(get_volume, VolCT, VolBead, VolLWH, \n                                 VolFinarelli, VolCT2, VolBead2, VolLWH2))\nhead(measurements.by.deer)\n\n# Reduce turns a binary function into one that accepts multiple inputs\n# Example: sum is equivalent of:\n# Reduce(\"+\", list(a, b, c, d, e))\n\n# define a simple binary function that calculates the (parallel)\n# maximum of two inputs:\npmax2 <- function(x, y) ifelse(x >= y, x, y)\nReduce(pmax2, measurements.by.deer)\n\n# Reduce repeatedly calls the binary function on pairs of inputs, so it can only\n# be used in those cases (e.g., not for calculating means)\n\n### Exercises\n# 13-1\ndata(\"hafu\", package = \"learningr\")\nhead(hafu)\nhafu$FatherQuestion <- str_detect(hafu$Father, fixed(\"?\"))\nhead(hafu)\nhafu$MotherQUestion <- str_detect(hafu$Mother, fixed(\"?\"))\nhafu <- within(hafu, {Father <- str_replace(Father, fixed(\"?\"), \"\")\n                      Mother <- str_replace(Mother, fixed(\"?\"), \"\")})\nhead(hafu)\n\n# 13-2\nhafu.long <- melt(hafu, measure.vars = c(\"Father\", \"Mother\"))\n\n# 13-3\n# Write a function that returns the 10 most common values in a vector,\n# along with their counts. Test it on hafu\n\nx <- c(1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 6, 6, 6, 6)\n\nGetMostCommonValues <- function(x) {\n  counts <- table(x, useNA = \"always\")\n  head(sort(counts, decreasing = TRUE), 10)\n}\nGetMostCommonValues(x)\nGetMostCommonValues(hafu$Mother)\n",
    "created" : 1430319500335.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "797423194",
    "id" : "545EE418",
    "lastKnownWriteTime" : 1429741502,
    "path" : "~/Documents/github/core-r/learning-r/C_13.R",
    "project_path" : "C_13.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}
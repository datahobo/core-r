{
    "contents" : "# lists\n# rank-based overlap calculations\n\n# start with position-weighted average overlap\n\n# testing - 0\n# 1/2 squared - 0.02, 0.12\n# same\nfirstList <- c(1,2,3,4,5,6,7,8,9,10)\nsecondList <- c(1,2,3,4,5,6,7,8,9,10)\n(RankBiasedOverlap(firstList, secondList, p = 0.9))\n(RankBiasedOverlap(firstList, secondList))\n# opposite\nfirstList <-  c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nsecondList <- c(10,9, 8, 7, 6, 5, 4, 3, 2, 1)\n(RankBiasedOverlap(firstList, secondList, p = 0.9))\n(RankBiasedOverlap(firstList, secondList))\n# top 3 similar - 0.52, 0.42\nfirstList <- c(1,2,3,4,5,6,7,8,9,10)\nsecondList <- c(1,2,3,7,8,9,4,10,5,6)\n(RankBiasedOverlap(firstList, secondList, p = 0.9))\n(RankBiasedOverlap(firstList, secondList))\n# top 2 similar 0.71\nfirstList <- c(1,2,3,4,5,6,7,8,9,10)\nsecondList <- c(1,2,8,7,6,5,4,10,9,3)\n(RankBiasedOverlap(firstList, secondList, p = 0.9))\n(RankBiasedOverlap(firstList, secondList))\n\n\n# another test - 0.25 ----\nfirstList <- c(1,2,3)\nsecondList <- c(3,2,1)\n# simplest case - 1\nfirstList <- c(1,2)\nsecondList <- c(1,3)\n# slightly longer - 1\n# sq - 0.75\nfirstList <- c(1, 2, 3)\nsecondList <- c(1, 2, 4)\n# slightly more different - 0.72\n# sq - 0.58\nfirstList <- c(1, 2, 3)\nsecondList <- c(1, 3, 4)\n# should be slightly higher - 0.83\n# sq - 0.64\nfirstList <- c(1, 2, 3)\nsecondList <- c(1, 3, 2)\n\n# top half is generally similar: 0.875 ----\nfirstList <- c(1, 2, 3, 4, 5)\nsecondList <- c(1, 2, 3, 4, 5)\n(RankBiasedOverlap(firstList, secondList, p = 0))\n# these should be in descending order of similarity\nsecondList <- c(1, 2, 3, 5, 4)\n(RankBiasedOverlap(firstList, secondList, p = 0.6))\nsecondList <- c(1, 2, 4, 3, 5)\n(RankBiasedOverlap(firstList, secondList, p = 0.6))\nsecondList <- c(1, 2, 4, 5, 3)\n(RankBiasedOverlap(firstList, secondList, p = 0.6))\nsecondList <- c(1, 3, 2, 4, 5)\n(RankBiasedOverlap(firstList, secondList, p = 0.6))\nsecondList <- c(2, 1, 3, 4, 5)\n(RankBiasedOverlap(firstList, secondList, p = 0.6))\nsecondList <- c(5, 4, 3, 2, 1)\n(RankBiasedOverlap(firstList, secondList, p = 0.6))\n# 1/2 squared - .64, .57\n\n## function ----\nRankBiasedOverlap <- function(firstList, \n                              secondList, \n                              listDepth = min(length(firstList), \n                                              length(secondList)), \n                              p = 0.5) {\n  # listDepth is how far into the list we will go\n  # set the initial parameter p such that 0 < p < 1 ----\n  ## when p = 0, only the top rank has any value\n  ## when p = 1, weights are approximately equal across the ranking\n  # p <- 0\n  if (p > 1) p <- 1\n  if (p < 0) p <- 0\n  # agreement is the vector of proportion of firstList and secondList that ----\n  ## that are overlapped at depth d\n  agreement <- NULL\n  # weight is the vector of convergent weights\n  weight <- NULL\n  # overlap is the cumulative overlap score\n  overlap <- 0\n  # infinite sum formula for total weight\n  totalWeight <- (1 - p)\n  for (d in 1:listDepth) {\n    # agreement is the proportion of both lists that are overlapped at d\n    agreement[d] <- (length(intersect(firstList[1:d], secondList[1:d])) / d)\n    # in the loop, the weight's value is p ^ d - 1\n    weight[d] <- (1 - p) * p ^ (d - 1)\n    newWeight <- sum(weight)\n    overlap <- overlap + (weight[d] * agreement[d])\n    print(paste(\"step\", d, \": weight:\", weight[d]))\n    print(paste(\"agreement:\", agreement[d]))\n    print(paste(\"overlap:\", overlap))\n    print(paste(\"net weight:\", sum(weight) * totalWeight))\n    print(paste(\"new weight:\", sum(weight) * newWeight))\n  }\n  newWeight <- (1 / sum(weight))\n  print(paste(\"cumulative weight:\", sum(weight) * totalWeight))\n  print(paste(\"totalWeight:\", totalWeight))\n  print(paste(\"newWeight:\", newWeight))\n  print(paste(\"trialScore:\", overlap * newWeight))\n  return(overlap * totalWeight)\n}\n\n# testing convergence\ncumulative <- 0\nweight <- NULL\np <- 0.1\nl <- 10\nfor (i in 1:l) {\n  cumulative <- cumulative + p ^ (1 / i)\n  print (paste(\"step \", i, \": score: \", cumulative, sep = \"\"))\n}\nprint(cumulative * (1 - p))\n\n(WeightedAverageOverlap(firstList, secondList))\nWeightedAverageOverlap <- function(firstList, secondList) {\n  overlap <- NULL\n  rankScore <- 0\n  # both lists do NOT need to be numeric, since we can compare product IDs\n  # Assume that both lists are rank-ordered\n  # let's change this to a version where we just compare based on the shorter list\n  loopCounter <- min(length(firstList), length(secondList))\n  # create the exponential weight for Zipf's distribution\n  expWeight <- 1.2\n  # now figure out the total weight based on Zipf's distribution\n  totalWeight <- sum(1/(firstList[1:loopCounter] ^ expWeight))\n  # now loop through the two lists, and do the comparison\n  for (i in 1:loopCounter) {\n    # get the similarity score for each list comparison\n    overlap[i] <- (length(intersect(firstList[1:i], secondList[1:i])) / i)\n    # troubleshoot the steps\n    print (paste(\"step \", i, \": overlap: \", overlap[i], \": total weight: \", totalWeight, sep = \"\"))\n    # even weighting of similarity scores\n    rankScore <- rankScore + (overlap[i] / i ^ expWeight)\n  }\n  return(rankScore / totalWeight)\n} \n\n",
    "created" : 1425319204997.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "48|39|65|24|\n122|59|143|0|\n",
    "hash" : "2882464854",
    "id" : "2EE76D32",
    "lastKnownWriteTime" : 1426090401,
    "path" : "~/Documents/github/r-common-code/lists.R",
    "project_path" : "lists.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}